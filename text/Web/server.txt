***Server programming

Notes for a course at Linnaeus University: https://coursepress.lnu.se/kurs/serverbaserad-webbprogrammering/

**Introduction

After the course you should be able to:
<ul>
Describe the task of a web server in different kinds of web applications.
Describe the purpose of the HTTP­ protocol in different types of web applications and their pros and cons in this context.
Use the Node.js platform and Express.js web application framework to build web applications.
Develope a create, read, update, delete (CRUD) web application using MongoDB to manage data persistence.
Describe and have a practical understanding of different security problems that can occur in web applications.
Create web applications with, for the context, suitable architecture.
Create server­-based real-time applications.
Plan and perform the publishing of web applications created for the Node.js platform in the production environment.
</ul>

The course is divided into three parts
<ul>
Part 1: Node.js, web servers, HTTP
Part 2: Backend web application, web security, web architecture
Part 3: Real-time application, publishing, and production
</ul>

Recommended literature:
<ul>
Chapter 17 and 20 of Eliquent JavaScript
Web Development with Node & Express, Ethan Brown
</ul>

<ul>
Node.js, npm
GitHub and GitLab!
Visual Studio Code or other IDE of your choice
Linting, ESLint
JSDoc, Document This
</ul>

**The Node platform

Node.js is not a web server nor a framework.

V8, Google chrome javascript engine, an event loop, and a low-level I/O API (libuv)

Small modules, doing one thing well, is the philosophy.

https://nodejs.org/api/esm.html ECMAScript modules

Single threaded event-driven architecture.

Event-driven programming:
<ul>
Callbacks
Promises
Async/Await
Event Emitters. Create your own events. Listen for multiple triggers of events
</ul>

Blocking or CPU-intensive code is not suitable for Node.js.

https://nodejs.org/api/cluster.html The cluster module allows easy creation of child processes that all share server ports.

npm install # installs all dependencies in package.json

yarn is an alternative to npm.

npm install mocha --save-dev

https://www.gitignore.io/

Use npx to execute a module (and install it temporarily)

Semantic Versioning (semver) major.minor.patch. Use * for latest.

The package-lock.json file describes the dependency tree and should be committed.

**Web servers

Different server services conventionally use certain ports.

Web servers are software that handles and understands HTTP/HTTPS request/response. Listen default on port 80 (HTTP) or port 443 (HTTPS)

<ul>
Apache. The A in LAMP-stack (Linux, Apache, MySQL, PHP)
Nginx. Uses an asynchronous event-driven approach to handling requests
IIS for Windows server (Internet Information Services). .NET
Apache Tomcat. A Java servlet, HTTP Connector, JSP engine. A Java servlet is a Java program that extends the capabilities of a server.
Node.js. A platform! Create a web server through code (APIs)!
</ul>

Apache:
<ul>
Most used web server.
Open source.
Launched in 1995.
Every request spawns a process stored in a thread pool.
Dynamic Modules: mod_access, mod_auth, mod_rewrite
.htaccess
</ul>

Nginx is a lightweight server commonly used as proxy or load balancer.

<code>
const http = require('http');
const PORT = 8080;

http.createServer((req, res) => {
  res.writeHead(200);
  res.end('Hello world\n');
}).listen(PORT);
</code>

Different kind of servers in a web environment
<ul>
Reverse proxy. Acts as a firewall and hides the origin.
Load balancer. Spread requests to several servers.
Cache server
Application server. Not limited to HTTP.
Virtual hosting. Multiple domain names.
</ul>

Domain name servers (DNS) translate domain names to IPs like 194.47.110.87 and 2001:6b0:52:4000::5:5

The browser sends a TCP/IP packet, the server sends back a reply for example on port 62365.

**HTTP

Stateless, securityless.

Internet Engineering Task Force (IETF) and the World Wide Web Consortium (W3C)

HTTP messages have headers.

<ul>
GET 	Get data; search result 	safe, idempotent
POST 	Create data 	unsafe, not idempotent
PUT 	Update data 	unsafe, idempotent
PATCH 	Partial update of resource 	unsafe, not idempotent
DELETE 	Delete a resource 	unsafe, idempotent
HEAD 	Just get headers 	safe, idempotent
OPTIONS 	Check what the server can do 	safe, idempotent
</ul>

Status codes:
<ul>
1xx - Informational. 101 Switching Protocols
2xx - Successful. 200 OK, 201 Created, 204 No Content
3xx - Redirection. 302 Found (follow "Location"), 304 Not Modified
4xx - Client Error. 400 Bad request, 401 Unauthorized, 403 Forbidden
5xx - Server Error. 500 Internal Server Error
</ul>

https://en.wikipedia.org/wiki/List_of_HTTP_header_fields

https://http.cat/ Status code cats.

The server should use gzip on text files  > 1-2 Kb

Do not trust client ID, nor server ID, neither a human. Filter out crawlers in logs.

Set-Cookie: PHPSESSID=1p0sptqdupf47lefnti1j1fg40 Path=/admin

<ul>
expires:Wed, 30 Jan 2019 14:00:00 GMT
cache-control: public, max-age=86400
cache-control: private, max-age=0, no-cache
ETag
</ul>

HTTP/2
<ul>
Multiplexing - one single TCP connection for many request
Server push (not as in Web Sockets)
Data Compression of HTTP Headers
Binary data streams
Priority flags
</ul>

**Web Architecture

<green>
<code>
const http = require('http')

const server = http.createServer((req, res) => {
  res.setHeader('Content-Type', 'text/plain')
  res.end('hello, world\n')
})

server.listen(8000, () => console.log('Server running at http://localhost:8000/'))
</code>
</div>

<code>
http.createServer((req, res) => {
  const path = req.url.replace(/\/?(?:\?.*)?$/, '').toLowerCase()

  switch (path) {
    case '':
      res.setHeader('Content-Type', 'text/plain')
      res.end('Homepage')
      break

    case '/about':
      res.setHeader('Content-Type', 'text/plain')
      res.end('About')
      break

    default:
      res.setHeader('Content-Type', 'text/plain')
      res.statusCode = 404
      res.end('Not Found')
      break
  }
}).listen(8000, () => console.log('Server running at http://localhost:8000/'))
</code>

MEAN full stack JavaScript: MongoDB, Express, Angular, Node.js

Handlebars view engine.

Backend frameworks:
<ul>
Express, https://expressjs.com/
Meteor, https://www.meteor.com/
Sails (built on Express), https://sailsjs.com/
Feathers (built on Express), https://feathersjs.com/
Fastify, https://www.fastify.io
</ul>

Express is inspired by Sinatra, a web application framework in Ruby, and intertwined with Connect, a pluggable Node module that can handle web requests (a.k.a. "middleware")

<code>
const express = require('express')
const app = express()

app.get('/', (req, res) => res.send('Homepage'))
app.get('/about', (req, res) => res.send('About'))

app.listen(8000, () => console.log('Server running at http://localhost:8000/'))
</code>

The directory structure can be
<ul>
app.js is the applications entry point.
Routes are stored in separate modules under the routes/ directory.
Controllers are stored under the controllers/ directory.
View templates are stored under the views/ directory.
Static files are stored under the public/ directory.
</ul>
https://gist.github.com/lancejpollard/1398757 or something else.

<ul>
express-hbs: Express handlebars template engine.
moment: Manage dates.
morgan: HTTP request logger.
nodemon: Automatically restarts the application when file changes. 
</ul>

Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle.
<ul>
Application-level: app.use() and app.METHOD(), (req, res, next)).
Router-level: same as application-level (use express.Router()).
Error-handling: an error-handling middleware function has four parameters, (err, req, res, next)).
Built-in: express.static, express.urlencoded
Third-party: Add functionality.
</ul>

router.get and router.post and app.use('/home', require('./routes/homeRouter'))

Controller functions render an HTML page using a template engine, res.render(view [, locals]) renders a view and sends the HTML string to the client.

Template engines: Pug, Mustache, EJS and 
https://handlebarsjs.com/ express-hbs

**Persistent data

MongoDB and Mongoose. Web sessions and flash messages.

Create, read, update and delete (CRUD) are the four basic function of persistent storage.

How to store application data at the server side?
<ul>
Data stored in the memory is non-persistent (data is erased when the power is turned off).
Filesystem persistence?    Hard to work with, performance, doesn't scale well.
Database persistence?    Oracle, SQL Server, MySQL, MariaDB, PostgreSQL,    MongoDB
Cloud persistence?    mongodb.com (DBaaS, Database-as-a-Service), AWS, Azure, Google Cloud

Relational database management systems (RDBMS) organizes data into tables with columns and rows with Structured Query Language (SQL).

NoSQL databases like MongoDB and Firebase are like big maps where incomplete documents can be easily stored and extended during development without time consuming database migrations.

MongoDB is open-source and derives from the word humongous. Stores JSON-like documents.

<ul>
https://www.mongodb.com/cloud/atlas MongoDB Atlas is a cloud database service.
https://mongoosejs.com/docs/index.html Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js.
https://docs.atlas.mongodb.com/getting-started/
</ul>

The mongoose.connect method returns a Promise, mongodb+srv://<dbuser>:<password>@<cluster>.mongodb.net/<name>?retryWrites=true&w=majority, listen for connection events: connected, error, disconnected.

Close the Mongoose connection when the Node process ends.

<code>
const shoeSchema = new mongoose.Schema({
  name: { type: String, required: true},
  size: { type: Number, required: true, min: 15, max: 47 }
})
</code>

The lowercase name of the collection will automatically be the plural version of the model's name.
<code>
const Shoe = new mongoose.model('Shoe', shoeSchema)
const myShoe = new Shoe();
</code>

The module (Task.js) resides in the models directory.

<ul>
/tasks
/tasks/:id
/tasks/new
/tasks/create
/tasks/:id/edit
/tasks/:id/update
/tasks/:id/remove
/tasks/:id/delete
</ul>

<code>
router.get('/:id/edit', tasksController.edit)
router.post'/:id/update', tasksController.update)
</code>

The captured values are populated in the req.params object, with the name of the route parameter specified in the path as their respective keys.

<code>
const task = new Task({
	description: req.body.description,
	done: req.body.done
})
await task.save()
</code>

Use Task.find, and pass an empty object, to find all documents in a collection. It's good practice to transform the documents into anonymous objects before passing the data to the view.

Use Task.updateOne (deleteOne) with { _id: req.body.id } to update a document in the database.

A session cookie keeps users logged in.

https://jwt.io Secure JSON Web Token

Redis is an in-memory database alternative to MongoDB.

The default server-side session storage MemoryStorage is not for production.

Session variables are just properties of the request object's session property: req.session.name = 'Ada'

To avoid "double posting" if a form page is refreshed return a redirect command instead of a view directly, 
https://en.wikipedia.org/wiki/Post/Redirect/Get the Post/Redirect/Get (PRG) pattern.

Whenever you redirect someone on your website it is a good idea to use a flash message to let them know that what they just did worked or not. The flash message should survive only a round trip. Use a session variable to save the message and delete the message on the next request.

req.session.flash = { type: 'success', text: 'The requested action was completed.' }


