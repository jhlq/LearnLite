***Client based programming

Notes for a course at Linnaeus University: https://coursepress.lnu.se/kurs/klientbaserad-webbprogrammering/

**L0 Introduction

3 parts:
<ul>
SSGs (Static Site Generators) and CSS preprocessors
DOM, Async and storage (event-driven asynchronous programming)
SPA (Single page applications)
</ul>

Describe the web browser (internal structure, security models, developer tools)

JavaScript, HTML and CSS should be clearly separated.

DOM (traversing, selecting, manipulating). Handling events.

Ajax and JSON.

SPAs with offline support and browser native APIs.

Handling history in the browser.

Literature: 
<ul>
http://eloquentjavascript.net/ Chapter 12-19, 22 of Eloquent JavaScript.
Optionally Professional JavaScript for Web Developers, 4th Edition by Matt Frisbie
</ul>

Tools:
<ul>
Git
Visual Studio Code (or better IDE)
Node.js (latest stable), npm
Standard.js
Webpack
Docker
Jekyll, Sass
Gatsby.js
</ul>

**L1

CSS preprocessors extend the CSS language.

Preprocessors enable calculations, nesting, mixins and variables.

The course default is sass, other options include less and stylus.

Partials, @import and operators.

https://sass-lang.com/guide

@mixin defines a function used with @include

@import "_partial";

width: 300px / $width * 100%;

Since line numbers in browser no longer match line numbers in source debugging gets harder. 
https://adamsilver.io/articles/the-disadvantages-of-css-preprocessors/ It’s easy to add a CSS preprocessor to the tech stack. But, it’s not easy to remove it down the line, should we so choose.

The .map files enable debugging.

Static Site Generators take for example plain text and generate html code. 
https://github.com/jhlq/LearnLite/blob/master/text/ppp.jl This website is built with a custom SSG written in Julia.

https://davidwalsh.name/introduction-static-site-generators SSGs are simple and secure.

<ul>
Jekyll
Gatsby.js
Octopress
GitBook
Middleman
Hugo
</ul>

Features:
<ul>
Partials for navigation etc
Layouts
Templates
Markdown (md) support
</ul>

Import partials from _includes folder with: {% include head.html %}

<code>
< ul >
	{% for post in site.posts %}
		< li >
			< a href="{{ post.url }}" >{{ post.title }}< /a >
		< /li >
	{% endfor %}
< /ul >
</code>

In Jekyll Liquid is the templating engine

Realtime content has to be brought in with JavaScript and user input handled with third party form receivers.

Getting started:
<ul>
Install Jekyll. Requires Ruby, RubyGems and NodeJS.
Create a new site: jekyll new myblog
Edit the site
Build: cd myblog; jekyll serve
Goto localhost:4000
</ul>

First assignment:
<ul>
Create a static site using Jekyll and sass
All CSS should be generated
Comment functionality
Open graph for sharing
https://www.docker.com/ Docker prevents pollution
https://github.com/1dv022/jekyll-boilerplate
</ul>

**L2

<ul>
Statistics
Compatibility
Internals
Devtools
Script loading
Sandboxing
Pollution
Webpack
</ul>

Chrome is the most used browser followed by Safari and then FireFox.

http://caniuse.com/

UI, rendering engine, js engine, network layer, cookies, web storage, cache.

Rendering engines: Blink, Gecko, WebKit

JavaScript engines: V8, SpiderMonkey, WebKit

Load content in the background (XHR / WS)

Sandboxing prevents JavaScript from:
<ul>
Reading the local file system.
Access some APIs without permission.
Communicate with third party servers, CORS (Cross Origin Resouce Sharing) solves this.
Find out the correct color of a link.
</ul>

< script src="js/app.js" >< /script > (Avoid coding directly within script tags), 
https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html add async or defer to modify loading behaviour.
 Specify type="module" to use ESM.

In the browser all variables are attached to the window object.

ESM benefits:
<ul>
'use strict' is standard
Provides variable scoping
Evaluated only once
Executed asynchronosly
</ul>

<code>
import { a as b } from './foo.js'
import { a } from './foo.js'
import * as nspace from './foo.js'
</code>

<code>
export class MyClass {
	constructor(){

	}
}
</code>

Developer tools:
<ul>
Inspect the code
Watch network traffic
Debug JavaScript
Track down memoryleaks and bottlenecks with timelines/profiling
Console
</ul>

**L3

DOM:
<ul>
Traversing
Selecting
Manipulating
Templates
Custom elements
Shadow DOM
</ul>

<ul>
Event delegation
Timers
Event loop
</ul>

The Document Object Model is an API for the rendering engine.

Traversing the DOM:
<ul>
firstChild
firstElementChild
parentNode
lastChild
lastElementChild
nextElementSibling
previousElementSibling
childNodes
children
</ul>

Select nodes:
<ul>
getElementById
getElementsByTagName
getElementsByClassName
querySelector
querySelectorAll
</ul>

let tags = document.querySelectorAll('p.tag')

let pTagsArray = Array.from(pTagsNodeList)

node.
<ul>
appendChild
inserBefore
replaceChild
removeChild
cloneNode
</ul>

<code>
let newTag = document.createElement('p')
let newText = document.createTextNode('Cool text!')
newTag.appendChild(newText)
document.querySelector('#main').appendChild(newTag)
</code>

Both textContent and innerHTML remove all children, textContent is more secure.

getAttribute, setAttribute, removeAttribute

node.style.color = '#AA5698'

Avoid css in js except dynamic properties: movingElement.style.left = '${x}px'

Use classes instead: node.classList.add('jschanged'), .remove, .toggle, .contains

Clone template nodes.

<code>
class BartBoard extends window.HTMLElement {
	constructor() {
	    super()        
	}

	connectedCallback () { // Called when added to the document
	    let text = this.hasAttribute('text') ? this.getAttribute('text') : ''
	    this.textContent = Array(10).join(text)
	} 
}
window.customElements.define('bart-board', BartBoard)
</code>

<yellow>
<code>
class BartBoard extends window.HTMLElement {
	constructor() {
	    super()        
	}
	connectedCallback () {
	    this._updateRendering()
	}

	static get observedAttributes() {
	    return ['text'];
	}
	attributeChangedCallback(name, oldValue, newValue) {
	    this._updateRendering()
	}

	_updateRendering() {
	    let text = this.hasAttribute('text') ? this.getAttribute('text') : ''
	    this.textContent = Array(10).join(text)
	}
}
<code>
</div>

<red>
<code>
class BartBoard extends window.HTMLElement {
	constructor () {
		super()
		this.attachShadow({mode: 'open'})
		this.shadowRoot.appendChild(template.content.cloneNode(true))
	}
	...
	_updateRendering() {
		let text = this.hasAttribute('text') ? this.getAttribute('text') : ''
		this.shadowRoot.querySelector('#board-text').textContent = Array(10).join(text)
}
</code>
</div>

https://developers.google.com/web/fundamentals/web-components/
